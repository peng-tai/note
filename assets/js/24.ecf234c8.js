(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{516:function(a,t,s){"use strict";s.r(t);var r=s(6),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"单一原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单一原则"}},[a._v("#")]),a._v(" 单一原则")]),a._v(" "),s("p",[a._v("就一个类而言，应该仅有一个引起它变化的原因。SRP原则的体现为：一个对象（方法）只做一件事。")]),a._v(" "),s("h3",{attrs:{id:"代理模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理模式"}},[a._v("#")]),a._v(" 代理模式")]),a._v(" "),s("p",[a._v("在图片预加载的例子中，通过虚拟代理实现预加载，将添加img和预加载的功能拆分到两个对象中，使每个对象各自只有一个修改的动机。")]),a._v(" "),s("h3",{attrs:{id:"迭代器模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[a._v("#")]),a._v(" 迭代器模式")]),a._v(" "),s("p",[a._v("将遍历对象内部各元素的部分提取出来，使遍历和处理各元素的具体逻辑分离。以后新增迭代的方式，也不会修改处理元素的函数。")]),a._v(" "),s("h3",{attrs:{id:"单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),s("p",[a._v("使用通用单例模式，将一个普通的类转变成单例类，使单例类的功能和普通类的功能进行了分离。")]),a._v(" "),s("h3",{attrs:{id:"装饰者模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰者模式"}},[a._v("#")]),a._v(" 装饰者模式")]),a._v(" "),s("p",[a._v("装饰者模式最大的特点就是“及用及付”，在用到的时候动态增加职责，也是一种分离职责的方式。")]),a._v(" "),s("h3",{attrs:{id:"何时应该分离职责"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何时应该分离职责"}},[a._v("#")]),a._v(" 何时应该分离职责")]),a._v(" "),s("p",[a._v("要明确的是，并不是所有职责都应该一一分离。")]),a._v(" "),s("ul",[s("li",[a._v("如果随着需求的变化，两个职责总是同时发生变化，那就没必要分离他们。")]),a._v(" "),s("li",[a._v("在职责发生变化的时候，再进行分离。")])]),a._v(" "),s("h2",{attrs:{id:"srp优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#srp优缺点"}},[a._v("#")]),a._v(" SRP优缺点")]),a._v(" "),s("p",[a._v("优点：")]),a._v(" "),s("ul",[s("li",[a._v("将对象分解成更小的粒度，有助于代码复用，便于单元测试，同时不会影响到其他职责。\n缺点：")]),a._v(" "),s("li",[a._v("增加编码复杂度，增大了对象之间相互联系的难度。")])]),a._v(" "),s("h2",{attrs:{id:"最少知识原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最少知识原则"}},[a._v("#")]),a._v(" 最少知识原则")]),a._v(" "),s("p",[a._v("最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。")]),a._v(" "),s("h3",{attrs:{id:"中介模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中介模式"}},[a._v("#")]),a._v(" 中介模式")]),a._v(" "),s("p",[a._v("通过增加中介者对象，让所有相关的对象都通过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象即可。")]),a._v(" "),s("h2",{attrs:{id:"开放封闭原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭原则"}},[a._v("#")]),a._v(" 开放封闭原则")]),a._v(" "),s("p",[a._v("当需要改变一个程序的功能或者给这个程序新增新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源码。")]),a._v(" "),s("h3",{attrs:{id:"发布-订阅模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式"}},[a._v("#")]),a._v(" 发布-订阅模式")]),a._v(" "),s("p",[a._v("它可以取代对象之间硬编码的通知机制，新增订阅者时，发布者的代码不需要修改；修改发布者时，也不会影响到之间的订阅者。")]),a._v(" "),s("h3",{attrs:{id:"模板方法模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式"}},[a._v("#")]),a._v(" 模板方法模式")]),a._v(" "),s("p",[a._v("通过新增子类，就能给系统添加新功能，而不需要改动其他的子类。")]),a._v(" "),s("h3",{attrs:{id:"策略模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[a._v("#")]),a._v(" 策略模式")]),a._v(" "),s("p",[a._v("将各种算法封装成单独的策略类，新增策略完全不会影响到之前的代码。")]),a._v(" "),s("h3",{attrs:{id:"代理模式-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理模式-2"}},[a._v("#")]),a._v(" 代理模式")]),a._v(" "),s("p",[a._v("在代理中添加处理和控制，使被代理的对象只需要专注于自己的职责。")]),a._v(" "),s("h3",{attrs:{id:"职责链模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#职责链模式"}},[a._v("#")]),a._v(" 职责链模式")]),a._v(" "),s("p",[a._v("通过新增职责链中的节点来新增处理请求的逻辑。")]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("设计原则只是在程序设计中起到指导的作用，并不一定要强制遵守。在程序设计中，我们可以做到以下两点：")]),a._v(" "),s("ul",[s("li",[a._v("挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。")]),a._v(" "),s("li",[a._v("在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。比如：修改配置文件，往往比修改源码要简单得多。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);